---
title: "Assignment 2: Parallelisation"
author: "Mishka Ramraj"
format: html
---


### Load necessary packages

```{r, output = F}

library(doParallel)
library(foreach)
library(MASS)
library(boot)
library(iterators)
library(knitr)
```


## Question 1

Below is the code associated with 2 methods. The first uses foreach() for a sequential functionality and the second for parallelisation.

```{r}

exp_random <- function() {
  sample <- rexp(1000, 1)
  m <- mean(sample)
  v <- var(sample)
  
  vals <- list(mean = m, variance = v)
  
}


## Sequentially
results1.1 <- foreach(i = 1:100, .combine = rbind) %do% {
  exp_random()
}


## Parallelisation

cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)

results1.2 <- foreach(i = 1:100, .combine = rbind) %dopar% {
  exp_random()
}

stopCluster(cl)

```


## Question 2

Table 1.1 displays that sequential methods are quicker when just considering one bootstrap sample at a time. However, when considering 100 Bootstraps samples at a time, parallelisation yields a shorter time. In this demonstration, parallelisation using multiple bootstraps samples at once was faster by about 2.7 seconds.


```{r, results = 'asis', echo = F}


## Single bootstraps----------------------
Bstrap <- function() {
  bs <- sample(galaxies, replace = T)
  med <- median(bs)
  
  return(med)
}

### PARALLELISATION

TrueMed <- median(galaxies) #20833.5

t1 <- system.time({
  cl <- makeCluster(detectCores() - 1)
  registerDoParallel(cl)
  
  results2.1 <- foreach(i = 1:100, .combine = rbind, .packages='MASS') %dopar% {
    Bstrap()
  }
  
  stopCluster(cl)
})

### SEQUENTIAL

bs_vals <- numeric(100)


t2 <- system.time({
  for (i in 1:100) {
    bs_vals[i] <- Bstrap()
  }
})

## multiple bootstraps----------------------

multiple_BS <- function() {
  mBS <- numeric(1000)
  for (i in 1:1000) {
    mBS[i] <- Bstrap()
  }
  return(invisible(mBS))
}

multiple_BS()


### PARALLELISATION

t3 <- system.time({
  cl <- makeCluster(detectCores() - 1)
  registerDoParallel(cl)
  
  results2.2 <- foreach(i = 1:100, .combine = rbind, .packages='MASS') %dopar% {
    multiple_BS()
  }
  
  stopCluster(cl)
  
})

### SEQUENTIAL

t4 <- system.time({
  for (i in 1:100) {
    multiple_BS()
  }
})


# Compare program times

single_parallel <- t1
single_sequential <- t2
multiple_parallel <- t3
multiple_sequential <- t4

t <- rbind(single_parallel, single_sequential, multiple_parallel, multiple_sequential)

knitr::kable(t, caption = "Time taken to perform bootstrapping tasks using sequential and parallelised methods.")


```


## Question 3 

In order to estimate the coverage of a bootstrap confidence interval, a sample was taken from the exponential(1) distribution. From this, the sample statistic (mean) was calculated and 100 boostraps taken. A 95% confidence interval was constructed. This process was repeated 1000 times so that we accumulated 1000 bootstrap confidence intervals. From all of these, the proportion of confidence intervals containing the true mean (1) was calculated. This told us the *coverage* of the bootstrap confidence intervals.

```{r, echo = F}


original_samp <- function() {
  
  os <- rexp(50, 1)
  return(invisible(os))
}



bs <- function(x) {
  
  bs <- sample(x, replace = T)
  bs_mean <- mean(bs)
  return(bs_mean)
}


encompass <- function() {
  os <- original_samp()
  
  bs_means <- numeric(1000)
  
  for (i in 1:1000) {
    bs_means[i] <- bs(os)
  }
  
  quants <- quantile(bs_means, probs = c(0.025, 0.975))
  
  OS_mean <- mean(os)
  
  CI <- sort(c(2*OS_mean - quants[2], 2*OS_mean - quants[1]))
  #CI2 <- boot.ci(bs_means, type = "perc")
  
  
  return(CI)
  
}

#encompass()

# repeat encompass function multiple times eg 1000
# will use parallelisation


cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)

results3.1 <- foreach(i = 1:1000, .combine = rbind) %dopar% {
  encompass()
}

stopCluster(cl)

counter <- numeric(nrow(results3.1))

for (i in 1:nrow(results3.1)) {
  if (results3.1[i, 1] < 1) {
    if (results3.1[i, 2] > 1) {
      counter[i] <- 1
    }
  } else{
    counter[i] <- 0
  }
}

coverage <- sum(counter)/ length(counter)
#coverage


```

In this scenario, the value for coverage is `r coverage`.